// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: CampusService.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Api_DeviceType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case ios // = 0
  case android // = 1
  case windows // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .ios
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ios
    case 1: self = .android
    case 2: self = .windows
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .ios: return 0
    case .android: return 1
    case .windows: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Api_DeviceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Api_DeviceType] = [
    .ios,
    .android,
    .windows,
  ]
}

#endif  // swift(>=4.2)

struct Api_RegisterDeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var publicKey: String {
    get {return _publicKey ?? String()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  var deviceType: Api_DeviceType = .ios

  var campusApiToken: String {
    get {return _campusApiToken ?? String()}
    set {_campusApiToken = newValue}
  }
  /// Returns true if `campusApiToken` has been explicitly set.
  var hasCampusApiToken: Bool {return self._campusApiToken != nil}
  /// Clears the value of `campusApiToken`. Subsequent reads from it will return its default value.
  mutating func clearCampusApiToken() {self._campusApiToken = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publicKey: String? = nil
  fileprivate var _campusApiToken: String? = nil
}

struct Api_RegisterDeviceReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_RemoveDeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var deviceType: Api_DeviceType = .ios

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_RemoveDeviceReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_IOSDeviceRequestResponseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String = String()

  var payload: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_IOSDeviceRequestResponseReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetRoomScheduleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var room: Int32 = 0

  var start: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _start ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {self._start = nil}

  var end: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _end ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  mutating func clearEnd() {self._end = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _start: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _end: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Api_GetRoomScheduleReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var events: [Api_GetRoomScheduleReply.RoomScheduleEvent] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct RoomScheduleEvent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var start: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _start ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_start = newValue}
    }
    /// Returns true if `start` has been explicitly set.
    var hasStart: Bool {return self._start != nil}
    /// Clears the value of `start`. Subsequent reads from it will return its default value.
    mutating func clearStart() {self._start = nil}

    var end: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _end ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_end = newValue}
    }
    /// Returns true if `end` has been explicitly set.
    var hasEnd: Bool {return self._end != nil}
    /// Clears the value of `end`. Subsequent reads from it will return its default value.
    mutating func clearEnd() {self._end = nil}

    var title: String = String()

    var eventID: Int32 = 0

    var courseCode: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _start: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _end: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  init() {}
}

struct Api_GetRoomCoordinatesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var archID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetRoomCoordinatesReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var utmZone: String = String()

  var utmEasting: Float = 0

  var utmNorthing: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetRoomMapsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var archID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetRoomMapsReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var maps: [Api_GetRoomMapsReply.Map] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Map {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mapID: Int64 = 0

    var description_p: String = String()

    var scale: Int64 = 0

    var width: Int64 = 0

    var height: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Api_GetLocationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var location: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetLocationsReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var locations: [Api_GetLocationsReply.Location] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Location {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var location: String = String()

    var name: String = String()

    var lon: String = String()

    var lat: String = String()

    var radius: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Api_SearchRoomsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var query: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_SearchRoomsReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rooms: [Api_Room] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_Room {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var roomID: Int32 = 0

  var roomCode: String = String()

  var buildingNr: String = String()

  var archID: String = String()

  var info: String = String()

  var address: String = String()

  var purpose: String = String()

  var campus: String = String()

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_NewsSourceArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sources: [Api_NewsSource] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_NewsSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var source: String = String()

  var title: String = String()

  var icon: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetTopNewsReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var imageURL: String = String()

  var link: String = String()

  var created: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _created ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  var hasCreated: Bool {return self._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  mutating func clearCreated() {self._created = nil}

  var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  mutating func clearFrom() {self._from = nil}

  var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  mutating func clearTo() {self._to = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _created: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Api_CafeteriaRatingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// cafeteriaId Mandatory Name of the cafeteria (EAT-API naming scheme "MENSA_GARCHING")
  var cafeteriaID: String = String()

  /// Optional Parameter to define an interval for the ratings (Lower bound)
  var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  mutating func clearFrom() {self._from = nil}

  /// Optional Parameter to define an interval for the ratings (Upper bound)
  var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  mutating func clearTo() {self._to = nil}

  /// Optional Parameter defines how many ratings are queried. If all ratings should be queried, enter "-1"
  var limit: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Api_DishRatingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Mandatory Name of the cafeteria (EAT-API naming scheme "MENSA_GARCHING")
  var cafeteriaID: String = String()

  /// Mandatory Name of the dish (EAT-API naming scheme) Must be available int the given mensa
  var dish: String = String()

  /// Optional Parameter to define an interval for the ratings (Lower bound)
  var from: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _from ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  mutating func clearFrom() {self._from = nil}

  /// Optional Parameter to define an interval for the ratings (Upper bound)
  var to: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _to ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  mutating func clearTo() {self._to = nil}

  /// Optional Parameter defines how many ratings are queried. If all ratings should be queried, enter "-1"
  var limit: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _from: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _to: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Api_CafeteriaRatingReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rating: [Api_SingleRatingReply] = []

  var avg: Double = 0

  var std: Double = 0

  var min: Int32 = 0

  var max: Int32 = 0

  var ratingTags: [Api_RatingTagResult] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_DishRatingReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rating: [Api_SingleRatingReply] = []

  var avg: Double = 0

  var std: Double = 0

  var min: Int32 = 0

  var max: Int32 = 0

  var ratingTags: [Api_RatingTagResult] = []

  var nameTags: [Api_RatingTagResult] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_SingleRatingReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// number in the range 1-5
  var points: Int32 = 0

  /// Optional JPEG image in Base64
  var image: Data = Data()

  /// Optional comment (max 256 chars)
  var comment: String = String()

  var ratingTags: [Api_RatingTagNewRequest] = []

  var visited: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _visited ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_visited = newValue}
  }
  /// Returns true if `visited` has been explicitly set.
  var hasVisited: Bool {return self._visited != nil}
  /// Clears the value of `visited`. Subsequent reads from it will return its default value.
  mutating func clearVisited() {self._visited = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _visited: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Api_NewCafeteriaRatingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// number in the range 1-5
  var points: Int32 = 0

  var cafeteriaID: String = String()

  var image: Data = Data()

  /// Optional list of tag ratings add as many tags with a rating (1-5) of the list of cafeteriaRatingTags
  var ratingTags: [Api_RatingTag] = []

  /// Optional comment (max 256 chars)
  var comment: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_NewDishRatingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// number in the range 1-5
  var points: Int32 = 0

  /// Mandatory Name of the dish (EAT-API naming scheme "MENSA_GARCHING") Must be available int the given mensa
  var cafeteriaID: String = String()

  /// Mandatory Name of the dish (EAT-API naming scheme) Must be available int the given mensa
  var dish: String = String()

  /// Optional JPEG image in Base64
  var image: Data = Data()

  /// Optional list of tag ratings add as many tags with a rating (1-5) of the list of dishRatingTags
  var ratingTags: [Api_RatingTag] = []

  /// Optional comment (max 256 chars)
  var comment: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetTagsReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ratingTags: [Api_TagsOverview] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_TagsOverview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tagID: Int32 = 0

  var de: String = String()

  var en: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_RatingTag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tagID: Int32 = 0

  var points: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_RatingTagNewRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tagID: Int32 = 0

  var points: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_RatingTagResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tagID: Int32 = 0

  var avg: Double = 0

  var std: Double = 0

  var min: Int32 = 0

  var max: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetCafeteriaReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cafeteria: [Api_Cafeteria] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_Cafeteria {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var address: String = String()

  var longitude: Double = 0

  var latitude: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetDishesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cafeteriaID: String = String()

  /// >=2022 until the current year
  var year: Int32 = 0

  /// range 1 - 53
  var week: Int32 = 0

  /// range 0 (Monday) - 4 (Friday)
  var day: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetDishesReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dish: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetResponsiblePersonReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var responsiblePerson: [Api_ResponsiblePersonElement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_ResponsiblePersonElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var telephone: String = String()

  var email: String = String()

  var faculty: String = String()

  var tumID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetBuilding2GpsReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var building2Gps: [Api_Building2GpsElement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_Building2GpsElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var latitude: String = String()

  var longitude: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetAreaFacilitiesByBuildingNrReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var areaFacilitiesByBuildingNr: [Api_RoomInformationElement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetAreaFacilitiesByBuildingNrRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var buildingNr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetListOfToiletsReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var listOfToilets: [Api_RoomInformationElement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_RoomInformationElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var roomID: Int32 = 0

  var roomCode: String = String()

  var buildingNr: String = String()

  var archID: String = String()

  var info: String = String()

  var address: String = String()

  var purpose: String = String()

  var campus: String = String()

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetListOfElevatorsReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var listOfElevators: [Api_RoomInformationElement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetMoreInformationReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var information: [Api_MoreInformationElement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_MoreInformationElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var category: String = String()

  var url: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetOpeningTimesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var language: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetOpeningTimesReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var facilities: [Api_OpeningTimesMsgElement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_OpeningTimesMsgElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 = 0

  var category: String = String()

  var name: String = String()

  var address: String = String()

  var room: String = String()

  var transportStation: String = String()

  var openingHours: String = String()

  var infos: String = String()

  var url: String = String()

  var language: String = String()

  var referenceID: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetUpdateNoteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetUpdateNoteReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetStudyRoomListReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rooms: [Api_StudyRoomMsgElement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_StudyRoomMsgElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 = 0

  var name: String = String()

  var details: String = String()

  var rooms: [Api_StudyRoom] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_StudyRoom {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupID: Int32 = 0

  var roomID: Int32 = 0

  var roomCode: String = String()

  var roomName: String = String()

  var buildingName: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetEventListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// optional parameter, will return all events if no id is specified
  var eventID: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetEventListReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var events: [Api_EventListMsgElement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_EventListMsgElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var path: String = String()

  var event: Int32 = 0

  var news: Int32 = 0

  var kino: Int32 = 0

  var file: Int32 = 0

  var title: String = String()

  var description_p: String = String()

  var locality: String = String()

  var link: String = String()

  var start: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _start ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {self._start = nil}

  var end: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _end ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  mutating func clearEnd() {self._end = nil}

  var ticketGroup: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _start: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _end: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Api_GetKinoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lastID: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetKinoReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kinos: [Api_KinoMsgElement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_KinoMsgElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  var kino: Int32 {
    get {return _storage._kino}
    set {_uniqueStorage()._kino = newValue}
  }

  var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {_uniqueStorage()._date = nil}

  var created: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._created ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._created = newValue}
  }
  /// Returns true if `created` has been explicitly set.
  var hasCreated: Bool {return _storage._created != nil}
  /// Clears the value of `created`. Subsequent reads from it will return its default value.
  mutating func clearCreated() {_uniqueStorage()._created = nil}

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var year: String {
    get {return _storage._year}
    set {_uniqueStorage()._year = newValue}
  }

  var runtime: String {
    get {return _storage._runtime}
    set {_uniqueStorage()._runtime = newValue}
  }

  var genre: String {
    get {return _storage._genre}
    set {_uniqueStorage()._genre = newValue}
  }

  var director: String {
    get {return _storage._director}
    set {_uniqueStorage()._director = newValue}
  }

  var actors: String {
    get {return _storage._actors}
    set {_uniqueStorage()._actors = newValue}
  }

  var rating: String {
    get {return _storage._rating}
    set {_uniqueStorage()._rating = newValue}
  }

  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var cover: Int32 {
    get {return _storage._cover}
    set {_uniqueStorage()._cover = newValue}
  }

  var trailer: String {
    get {return _storage._trailer}
    set {_uniqueStorage()._trailer = newValue}
  }

  var link: String {
    get {return _storage._link}
    set {_uniqueStorage()._link = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Api_SendFeedbackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var topic: String = String()

  var email: String = String()

  var emailID: String = String()

  var message: String = String()

  var imageCount: Int32 = 0

  var latitude: Double = 0

  var longitude: Double = 0

  var osVersion: String = String()

  var appVersion: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_SendFeedbackImageReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_SendFeedbackImageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Int32 = 0

  ///todo where does the file come from?
  var imageNr: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetMembersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lrzID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetMembersReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lrzID: String = String()

  var name: String = String()

  var memberID: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetUploadStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lrzID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetUploadStatusReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fcmToken: String = String()

  var publicKey: String = String()

  var studentID: Bool = false

  var employeeID: Bool = false

  var externalID: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetNotificationsReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var notificationID: Int32 = 0

  var type: Int32 = 0

  var title: String = String()

  var description_p: String = String()

  var signature: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_NotificationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var notificationID: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetNotificationsConfirmReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetCanteenHeadCountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested canteen ID
  var canteenID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Api_GetCanteenHeadCountReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The absolut count of humans in the canteen. Only valid in case percent != -1.
  var count: UInt32 = 0

  /// The maximum nunmber of humans in the canteen for the percent to be 100.00. Only valid in case percent != -1.
  var maxCount: UInt32 = 0

  /// Current capacity utilization of the canteen clamped to 0 and 100 or -1 in case no data is available.
  var percent: Float = 0

  /// A time stamp indicating how up to date the response is. Only valid in case percent != -1.
  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Api_DeviceType: @unchecked Sendable {}
extension Api_RegisterDeviceRequest: @unchecked Sendable {}
extension Api_RegisterDeviceReply: @unchecked Sendable {}
extension Api_RemoveDeviceRequest: @unchecked Sendable {}
extension Api_RemoveDeviceReply: @unchecked Sendable {}
extension Api_IOSDeviceRequestResponseRequest: @unchecked Sendable {}
extension Api_IOSDeviceRequestResponseReply: @unchecked Sendable {}
extension Api_GetRoomScheduleRequest: @unchecked Sendable {}
extension Api_GetRoomScheduleReply: @unchecked Sendable {}
extension Api_GetRoomScheduleReply.RoomScheduleEvent: @unchecked Sendable {}
extension Api_GetRoomCoordinatesRequest: @unchecked Sendable {}
extension Api_GetRoomCoordinatesReply: @unchecked Sendable {}
extension Api_GetRoomMapsRequest: @unchecked Sendable {}
extension Api_GetRoomMapsReply: @unchecked Sendable {}
extension Api_GetRoomMapsReply.Map: @unchecked Sendable {}
extension Api_GetLocationsRequest: @unchecked Sendable {}
extension Api_GetLocationsReply: @unchecked Sendable {}
extension Api_GetLocationsReply.Location: @unchecked Sendable {}
extension Api_SearchRoomsRequest: @unchecked Sendable {}
extension Api_SearchRoomsReply: @unchecked Sendable {}
extension Api_Room: @unchecked Sendable {}
extension Api_NewsSourceArray: @unchecked Sendable {}
extension Api_NewsSource: @unchecked Sendable {}
extension Api_GetTopNewsReply: @unchecked Sendable {}
extension Api_CafeteriaRatingRequest: @unchecked Sendable {}
extension Api_DishRatingRequest: @unchecked Sendable {}
extension Api_CafeteriaRatingReply: @unchecked Sendable {}
extension Api_DishRatingReply: @unchecked Sendable {}
extension Api_SingleRatingReply: @unchecked Sendable {}
extension Api_NewCafeteriaRatingRequest: @unchecked Sendable {}
extension Api_NewDishRatingRequest: @unchecked Sendable {}
extension Api_GetTagsReply: @unchecked Sendable {}
extension Api_TagsOverview: @unchecked Sendable {}
extension Api_RatingTag: @unchecked Sendable {}
extension Api_RatingTagNewRequest: @unchecked Sendable {}
extension Api_RatingTagResult: @unchecked Sendable {}
extension Api_GetCafeteriaReply: @unchecked Sendable {}
extension Api_Cafeteria: @unchecked Sendable {}
extension Api_GetDishesRequest: @unchecked Sendable {}
extension Api_GetDishesReply: @unchecked Sendable {}
extension Api_GetResponsiblePersonReply: @unchecked Sendable {}
extension Api_ResponsiblePersonElement: @unchecked Sendable {}
extension Api_GetBuilding2GpsReply: @unchecked Sendable {}
extension Api_Building2GpsElement: @unchecked Sendable {}
extension Api_GetAreaFacilitiesByBuildingNrReply: @unchecked Sendable {}
extension Api_GetAreaFacilitiesByBuildingNrRequest: @unchecked Sendable {}
extension Api_GetListOfToiletsReply: @unchecked Sendable {}
extension Api_RoomInformationElement: @unchecked Sendable {}
extension Api_GetListOfElevatorsReply: @unchecked Sendable {}
extension Api_GetMoreInformationReply: @unchecked Sendable {}
extension Api_MoreInformationElement: @unchecked Sendable {}
extension Api_GetOpeningTimesRequest: @unchecked Sendable {}
extension Api_GetOpeningTimesReply: @unchecked Sendable {}
extension Api_OpeningTimesMsgElement: @unchecked Sendable {}
extension Api_GetUpdateNoteRequest: @unchecked Sendable {}
extension Api_GetUpdateNoteReply: @unchecked Sendable {}
extension Api_GetStudyRoomListReply: @unchecked Sendable {}
extension Api_StudyRoomMsgElement: @unchecked Sendable {}
extension Api_StudyRoom: @unchecked Sendable {}
extension Api_GetEventListRequest: @unchecked Sendable {}
extension Api_GetEventListReply: @unchecked Sendable {}
extension Api_EventListMsgElement: @unchecked Sendable {}
extension Api_GetKinoRequest: @unchecked Sendable {}
extension Api_GetKinoReply: @unchecked Sendable {}
extension Api_KinoMsgElement: @unchecked Sendable {}
extension Api_SendFeedbackRequest: @unchecked Sendable {}
extension Api_SendFeedbackImageReply: @unchecked Sendable {}
extension Api_SendFeedbackImageRequest: @unchecked Sendable {}
extension Api_GetMembersRequest: @unchecked Sendable {}
extension Api_GetMembersReply: @unchecked Sendable {}
extension Api_GetUploadStatusRequest: @unchecked Sendable {}
extension Api_GetUploadStatusReply: @unchecked Sendable {}
extension Api_GetNotificationsReply: @unchecked Sendable {}
extension Api_NotificationsRequest: @unchecked Sendable {}
extension Api_GetNotificationsConfirmReply: @unchecked Sendable {}
extension Api_GetCanteenHeadCountRequest: @unchecked Sendable {}
extension Api_GetCanteenHeadCountReply: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "api"

extension Api_DeviceType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IOS"),
    1: .same(proto: "ANDROID"),
    2: .same(proto: "WINDOWS"),
  ]
}

extension Api_RegisterDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterDeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
    2: .same(proto: "publicKey"),
    3: .same(proto: "deviceType"),
    4: .same(proto: "campusApiToken"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._publicKey) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.deviceType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._campusApiToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try { if let v = self._publicKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.deviceType != .ios {
      try visitor.visitSingularEnumField(value: self.deviceType, fieldNumber: 3)
    }
    try { if let v = self._campusApiToken {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_RegisterDeviceRequest, rhs: Api_RegisterDeviceRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.deviceType != rhs.deviceType {return false}
    if lhs._campusApiToken != rhs._campusApiToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_RegisterDeviceReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterDeviceReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_RegisterDeviceReply, rhs: Api_RegisterDeviceReply) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_RemoveDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveDeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
    2: .same(proto: "deviceType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.deviceType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if self.deviceType != .ios {
      try visitor.visitSingularEnumField(value: self.deviceType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_RemoveDeviceRequest, rhs: Api_RemoveDeviceRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.deviceType != rhs.deviceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_RemoveDeviceReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveDeviceReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_RemoveDeviceReply, rhs: Api_RemoveDeviceReply) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_IOSDeviceRequestResponseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IOSDeviceRequestResponseRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requestId"),
    2: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularStringField(value: self.payload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_IOSDeviceRequestResponseRequest, rhs: Api_IOSDeviceRequestResponseRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_IOSDeviceRequestResponseReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IOSDeviceRequestResponseReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_IOSDeviceRequestResponseReply, rhs: Api_IOSDeviceRequestResponseReply) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetRoomScheduleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRoomScheduleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "room"),
    2: .same(proto: "start"),
    3: .same(proto: "end"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.room) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._start) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._end) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.room != 0 {
      try visitor.visitSingularInt32Field(value: self.room, fieldNumber: 1)
    }
    try { if let v = self._start {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetRoomScheduleRequest, rhs: Api_GetRoomScheduleRequest) -> Bool {
    if lhs.room != rhs.room {return false}
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetRoomScheduleReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRoomScheduleReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetRoomScheduleReply, rhs: Api_GetRoomScheduleReply) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetRoomScheduleReply.RoomScheduleEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Api_GetRoomScheduleReply.protoMessageName + ".RoomScheduleEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
    3: .same(proto: "title"),
    4: .standard(proto: "event_id"),
    5: .standard(proto: "course_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._start) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._end) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.eventID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.courseCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    if self.eventID != 0 {
      try visitor.visitSingularInt32Field(value: self.eventID, fieldNumber: 4)
    }
    if !self.courseCode.isEmpty {
      try visitor.visitSingularStringField(value: self.courseCode, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetRoomScheduleReply.RoomScheduleEvent, rhs: Api_GetRoomScheduleReply.RoomScheduleEvent) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs.title != rhs.title {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.courseCode != rhs.courseCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetRoomCoordinatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRoomCoordinatesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "arch_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.archID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.archID.isEmpty {
      try visitor.visitSingularStringField(value: self.archID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetRoomCoordinatesRequest, rhs: Api_GetRoomCoordinatesRequest) -> Bool {
    if lhs.archID != rhs.archID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetRoomCoordinatesReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRoomCoordinatesReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "utm_zone"),
    2: .standard(proto: "utm_easting"),
    3: .standard(proto: "utm_northing"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.utmZone) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.utmEasting) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.utmNorthing) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.utmZone.isEmpty {
      try visitor.visitSingularStringField(value: self.utmZone, fieldNumber: 1)
    }
    if self.utmEasting != 0 {
      try visitor.visitSingularFloatField(value: self.utmEasting, fieldNumber: 2)
    }
    if self.utmNorthing != 0 {
      try visitor.visitSingularFloatField(value: self.utmNorthing, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetRoomCoordinatesReply, rhs: Api_GetRoomCoordinatesReply) -> Bool {
    if lhs.utmZone != rhs.utmZone {return false}
    if lhs.utmEasting != rhs.utmEasting {return false}
    if lhs.utmNorthing != rhs.utmNorthing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetRoomMapsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRoomMapsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "arch_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.archID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.archID.isEmpty {
      try visitor.visitSingularStringField(value: self.archID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetRoomMapsRequest, rhs: Api_GetRoomMapsRequest) -> Bool {
    if lhs.archID != rhs.archID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetRoomMapsReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetRoomMapsReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "maps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.maps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.maps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.maps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetRoomMapsReply, rhs: Api_GetRoomMapsReply) -> Bool {
    if lhs.maps != rhs.maps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetRoomMapsReply.Map: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Api_GetRoomMapsReply.protoMessageName + ".Map"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "map_id"),
    2: .same(proto: "description"),
    3: .same(proto: "scale"),
    4: .same(proto: "width"),
    5: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.mapID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.scale) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.width) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mapID != 0 {
      try visitor.visitSingularInt64Field(value: self.mapID, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if self.scale != 0 {
      try visitor.visitSingularInt64Field(value: self.scale, fieldNumber: 3)
    }
    if self.width != 0 {
      try visitor.visitSingularInt64Field(value: self.width, fieldNumber: 4)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetRoomMapsReply.Map, rhs: Api_GetRoomMapsReply.Map) -> Bool {
    if lhs.mapID != rhs.mapID {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.scale != rhs.scale {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetLocationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLocationsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.location) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetLocationsRequest, rhs: Api_GetLocationsRequest) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetLocationsReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLocationsReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locations"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.locations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.locations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.locations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetLocationsReply, rhs: Api_GetLocationsReply) -> Bool {
    if lhs.locations != rhs.locations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetLocationsReply.Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Api_GetLocationsReply.protoMessageName + ".Location"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .same(proto: "name"),
    3: .same(proto: "lon"),
    4: .same(proto: "lat"),
    5: .same(proto: "radius"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.lon) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.lat) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.radius) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.lon.isEmpty {
      try visitor.visitSingularStringField(value: self.lon, fieldNumber: 3)
    }
    if !self.lat.isEmpty {
      try visitor.visitSingularStringField(value: self.lat, fieldNumber: 4)
    }
    if !self.radius.isEmpty {
      try visitor.visitSingularStringField(value: self.radius, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetLocationsReply.Location, rhs: Api_GetLocationsReply.Location) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.name != rhs.name {return false}
    if lhs.lon != rhs.lon {return false}
    if lhs.lat != rhs.lat {return false}
    if lhs.radius != rhs.radius {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SearchRoomsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SearchRoomsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "query"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.query) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SearchRoomsRequest, rhs: Api_SearchRoomsRequest) -> Bool {
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SearchRoomsReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SearchRoomsReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rooms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rooms) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rooms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rooms, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SearchRoomsReply, rhs: Api_SearchRoomsReply) -> Bool {
    if lhs.rooms != rhs.rooms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Room: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Room"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roomId"),
    2: .standard(proto: "room_code"),
    3: .standard(proto: "building_nr"),
    4: .standard(proto: "arch_id"),
    5: .same(proto: "info"),
    6: .same(proto: "address"),
    7: .same(proto: "purpose"),
    8: .same(proto: "campus"),
    9: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.roomID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.roomCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.buildingNr) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.archID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.info) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.purpose) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.campus) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roomID != 0 {
      try visitor.visitSingularInt32Field(value: self.roomID, fieldNumber: 1)
    }
    if !self.roomCode.isEmpty {
      try visitor.visitSingularStringField(value: self.roomCode, fieldNumber: 2)
    }
    if !self.buildingNr.isEmpty {
      try visitor.visitSingularStringField(value: self.buildingNr, fieldNumber: 3)
    }
    if !self.archID.isEmpty {
      try visitor.visitSingularStringField(value: self.archID, fieldNumber: 4)
    }
    if !self.info.isEmpty {
      try visitor.visitSingularStringField(value: self.info, fieldNumber: 5)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 6)
    }
    if !self.purpose.isEmpty {
      try visitor.visitSingularStringField(value: self.purpose, fieldNumber: 7)
    }
    if !self.campus.isEmpty {
      try visitor.visitSingularStringField(value: self.campus, fieldNumber: 8)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_Room, rhs: Api_Room) -> Bool {
    if lhs.roomID != rhs.roomID {return false}
    if lhs.roomCode != rhs.roomCode {return false}
    if lhs.buildingNr != rhs.buildingNr {return false}
    if lhs.archID != rhs.archID {return false}
    if lhs.info != rhs.info {return false}
    if lhs.address != rhs.address {return false}
    if lhs.purpose != rhs.purpose {return false}
    if lhs.campus != rhs.campus {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_NewsSourceArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewsSourceArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sources"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sources) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sources, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_NewsSourceArray, rhs: Api_NewsSourceArray) -> Bool {
    if lhs.sources != rhs.sources {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_NewsSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewsSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "title"),
    3: .same(proto: "icon"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_NewsSource, rhs: Api_NewsSource) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.title != rhs.title {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetTopNewsReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTopNewsReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "image_url"),
    2: .same(proto: "link"),
    3: .same(proto: "created"),
    4: .same(proto: "from"),
    5: .same(proto: "to"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.imageURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.link) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._created) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.imageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imageURL, fieldNumber: 1)
    }
    if !self.link.isEmpty {
      try visitor.visitSingularStringField(value: self.link, fieldNumber: 2)
    }
    try { if let v = self._created {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetTopNewsReply, rhs: Api_GetTopNewsReply) -> Bool {
    if lhs.imageURL != rhs.imageURL {return false}
    if lhs.link != rhs.link {return false}
    if lhs._created != rhs._created {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_CafeteriaRatingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CafeteriaRatingRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cafeteriaId"),
    2: .same(proto: "from"),
    3: .same(proto: "to"),
    4: .same(proto: "limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cafeteriaID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cafeteriaID.isEmpty {
      try visitor.visitSingularStringField(value: self.cafeteriaID, fieldNumber: 1)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_CafeteriaRatingRequest, rhs: Api_CafeteriaRatingRequest) -> Bool {
    if lhs.cafeteriaID != rhs.cafeteriaID {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_DishRatingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishRatingRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cafeteriaId"),
    2: .same(proto: "dish"),
    3: .same(proto: "from"),
    4: .same(proto: "to"),
    5: .same(proto: "limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cafeteriaID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dish) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cafeteriaID.isEmpty {
      try visitor.visitSingularStringField(value: self.cafeteriaID, fieldNumber: 1)
    }
    if !self.dish.isEmpty {
      try visitor.visitSingularStringField(value: self.dish, fieldNumber: 2)
    }
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_DishRatingRequest, rhs: Api_DishRatingRequest) -> Bool {
    if lhs.cafeteriaID != rhs.cafeteriaID {return false}
    if lhs.dish != rhs.dish {return false}
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_CafeteriaRatingReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CafeteriaRatingReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rating"),
    2: .same(proto: "avg"),
    3: .same(proto: "std"),
    4: .same(proto: "min"),
    5: .same(proto: "max"),
    6: .same(proto: "ratingTags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rating) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.avg) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.std) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.min) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.max) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.ratingTags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rating.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rating, fieldNumber: 1)
    }
    if self.avg != 0 {
      try visitor.visitSingularDoubleField(value: self.avg, fieldNumber: 2)
    }
    if self.std != 0 {
      try visitor.visitSingularDoubleField(value: self.std, fieldNumber: 3)
    }
    if self.min != 0 {
      try visitor.visitSingularInt32Field(value: self.min, fieldNumber: 4)
    }
    if self.max != 0 {
      try visitor.visitSingularInt32Field(value: self.max, fieldNumber: 5)
    }
    if !self.ratingTags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ratingTags, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_CafeteriaRatingReply, rhs: Api_CafeteriaRatingReply) -> Bool {
    if lhs.rating != rhs.rating {return false}
    if lhs.avg != rhs.avg {return false}
    if lhs.std != rhs.std {return false}
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.ratingTags != rhs.ratingTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_DishRatingReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DishRatingReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rating"),
    2: .same(proto: "avg"),
    3: .same(proto: "std"),
    4: .same(proto: "min"),
    5: .same(proto: "max"),
    6: .same(proto: "ratingTags"),
    7: .same(proto: "nameTags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rating) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.avg) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.std) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.min) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.max) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.ratingTags) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.nameTags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rating.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rating, fieldNumber: 1)
    }
    if self.avg != 0 {
      try visitor.visitSingularDoubleField(value: self.avg, fieldNumber: 2)
    }
    if self.std != 0 {
      try visitor.visitSingularDoubleField(value: self.std, fieldNumber: 3)
    }
    if self.min != 0 {
      try visitor.visitSingularInt32Field(value: self.min, fieldNumber: 4)
    }
    if self.max != 0 {
      try visitor.visitSingularInt32Field(value: self.max, fieldNumber: 5)
    }
    if !self.ratingTags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ratingTags, fieldNumber: 6)
    }
    if !self.nameTags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nameTags, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_DishRatingReply, rhs: Api_DishRatingReply) -> Bool {
    if lhs.rating != rhs.rating {return false}
    if lhs.avg != rhs.avg {return false}
    if lhs.std != rhs.std {return false}
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.ratingTags != rhs.ratingTags {return false}
    if lhs.nameTags != rhs.nameTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SingleRatingReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SingleRatingReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .same(proto: "image"),
    3: .same(proto: "comment"),
    4: .same(proto: "ratingTags"),
    5: .same(proto: "visited"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.points) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.image) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.ratingTags) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._visited) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.points != 0 {
      try visitor.visitSingularInt32Field(value: self.points, fieldNumber: 1)
    }
    if !self.image.isEmpty {
      try visitor.visitSingularBytesField(value: self.image, fieldNumber: 2)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 3)
    }
    if !self.ratingTags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ratingTags, fieldNumber: 4)
    }
    try { if let v = self._visited {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SingleRatingReply, rhs: Api_SingleRatingReply) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.image != rhs.image {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs.ratingTags != rhs.ratingTags {return false}
    if lhs._visited != rhs._visited {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_NewCafeteriaRatingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewCafeteriaRatingRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .same(proto: "cafeteriaId"),
    3: .same(proto: "image"),
    4: .same(proto: "ratingTags"),
    6: .same(proto: "comment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.points) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cafeteriaID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.image) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.ratingTags) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.points != 0 {
      try visitor.visitSingularInt32Field(value: self.points, fieldNumber: 1)
    }
    if !self.cafeteriaID.isEmpty {
      try visitor.visitSingularStringField(value: self.cafeteriaID, fieldNumber: 2)
    }
    if !self.image.isEmpty {
      try visitor.visitSingularBytesField(value: self.image, fieldNumber: 3)
    }
    if !self.ratingTags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ratingTags, fieldNumber: 4)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_NewCafeteriaRatingRequest, rhs: Api_NewCafeteriaRatingRequest) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.cafeteriaID != rhs.cafeteriaID {return false}
    if lhs.image != rhs.image {return false}
    if lhs.ratingTags != rhs.ratingTags {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_NewDishRatingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NewDishRatingRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .same(proto: "cafeteriaId"),
    3: .same(proto: "dish"),
    4: .same(proto: "image"),
    5: .same(proto: "ratingTags"),
    7: .same(proto: "comment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.points) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cafeteriaID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dish) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.image) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.ratingTags) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.points != 0 {
      try visitor.visitSingularInt32Field(value: self.points, fieldNumber: 1)
    }
    if !self.cafeteriaID.isEmpty {
      try visitor.visitSingularStringField(value: self.cafeteriaID, fieldNumber: 2)
    }
    if !self.dish.isEmpty {
      try visitor.visitSingularStringField(value: self.dish, fieldNumber: 3)
    }
    if !self.image.isEmpty {
      try visitor.visitSingularBytesField(value: self.image, fieldNumber: 4)
    }
    if !self.ratingTags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ratingTags, fieldNumber: 5)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_NewDishRatingRequest, rhs: Api_NewDishRatingRequest) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.cafeteriaID != rhs.cafeteriaID {return false}
    if lhs.dish != rhs.dish {return false}
    if lhs.image != rhs.image {return false}
    if lhs.ratingTags != rhs.ratingTags {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetTagsReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTagsReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ratingTags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ratingTags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ratingTags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ratingTags, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetTagsReply, rhs: Api_GetTagsReply) -> Bool {
    if lhs.ratingTags != rhs.ratingTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_TagsOverview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TagsOverview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tagId"),
    2: .same(proto: "de"),
    3: .same(proto: "en"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.tagID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.de) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.en) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tagID != 0 {
      try visitor.visitSingularInt32Field(value: self.tagID, fieldNumber: 1)
    }
    if !self.de.isEmpty {
      try visitor.visitSingularStringField(value: self.de, fieldNumber: 2)
    }
    if !self.en.isEmpty {
      try visitor.visitSingularStringField(value: self.en, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_TagsOverview, rhs: Api_TagsOverview) -> Bool {
    if lhs.tagID != rhs.tagID {return false}
    if lhs.de != rhs.de {return false}
    if lhs.en != rhs.en {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_RatingTag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RatingTag"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tagId"),
    2: .same(proto: "points"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.tagID) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.points) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tagID != 0 {
      try visitor.visitSingularInt32Field(value: self.tagID, fieldNumber: 1)
    }
    if self.points != 0 {
      try visitor.visitSingularDoubleField(value: self.points, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_RatingTag, rhs: Api_RatingTag) -> Bool {
    if lhs.tagID != rhs.tagID {return false}
    if lhs.points != rhs.points {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_RatingTagNewRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RatingTagNewRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tagId"),
    2: .same(proto: "points"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.tagID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.points) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tagID != 0 {
      try visitor.visitSingularInt32Field(value: self.tagID, fieldNumber: 1)
    }
    if self.points != 0 {
      try visitor.visitSingularInt32Field(value: self.points, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_RatingTagNewRequest, rhs: Api_RatingTagNewRequest) -> Bool {
    if lhs.tagID != rhs.tagID {return false}
    if lhs.points != rhs.points {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_RatingTagResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RatingTagResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tagId"),
    2: .same(proto: "avg"),
    3: .same(proto: "std"),
    4: .same(proto: "min"),
    5: .same(proto: "max"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.tagID) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.avg) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.std) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.min) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.max) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tagID != 0 {
      try visitor.visitSingularInt32Field(value: self.tagID, fieldNumber: 1)
    }
    if self.avg != 0 {
      try visitor.visitSingularDoubleField(value: self.avg, fieldNumber: 2)
    }
    if self.std != 0 {
      try visitor.visitSingularDoubleField(value: self.std, fieldNumber: 3)
    }
    if self.min != 0 {
      try visitor.visitSingularInt32Field(value: self.min, fieldNumber: 4)
    }
    if self.max != 0 {
      try visitor.visitSingularInt32Field(value: self.max, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_RatingTagResult, rhs: Api_RatingTagResult) -> Bool {
    if lhs.tagID != rhs.tagID {return false}
    if lhs.avg != rhs.avg {return false}
    if lhs.std != rhs.std {return false}
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetCafeteriaReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetCafeteriaReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cafeteria"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cafeteria) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cafeteria.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cafeteria, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetCafeteriaReply, rhs: Api_GetCafeteriaReply) -> Bool {
    if lhs.cafeteria != rhs.cafeteria {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Cafeteria: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Cafeteria"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "address"),
    3: .same(proto: "longitude"),
    4: .same(proto: "latitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 3)
    }
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_Cafeteria, rhs: Api_Cafeteria) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.address != rhs.address {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetDishesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDishesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cafeteriaId"),
    2: .same(proto: "year"),
    3: .same(proto: "week"),
    4: .same(proto: "day"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cafeteriaID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.year) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.week) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.day) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cafeteriaID.isEmpty {
      try visitor.visitSingularStringField(value: self.cafeteriaID, fieldNumber: 1)
    }
    if self.year != 0 {
      try visitor.visitSingularInt32Field(value: self.year, fieldNumber: 2)
    }
    if self.week != 0 {
      try visitor.visitSingularInt32Field(value: self.week, fieldNumber: 3)
    }
    if self.day != 0 {
      try visitor.visitSingularInt32Field(value: self.day, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetDishesRequest, rhs: Api_GetDishesRequest) -> Bool {
    if lhs.cafeteriaID != rhs.cafeteriaID {return false}
    if lhs.year != rhs.year {return false}
    if lhs.week != rhs.week {return false}
    if lhs.day != rhs.day {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetDishesReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDishesReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dish"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.dish) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dish.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dish, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetDishesReply, rhs: Api_GetDishesReply) -> Bool {
    if lhs.dish != rhs.dish {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetResponsiblePersonReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetResponsiblePersonReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "responsiblePerson"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.responsiblePerson) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.responsiblePerson.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responsiblePerson, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetResponsiblePersonReply, rhs: Api_GetResponsiblePersonReply) -> Bool {
    if lhs.responsiblePerson != rhs.responsiblePerson {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_ResponsiblePersonElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponsiblePersonElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "telephone"),
    3: .same(proto: "email"),
    4: .same(proto: "faculty"),
    5: .same(proto: "tumID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.telephone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.faculty) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.tumID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.telephone.isEmpty {
      try visitor.visitSingularStringField(value: self.telephone, fieldNumber: 2)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 3)
    }
    if !self.faculty.isEmpty {
      try visitor.visitSingularStringField(value: self.faculty, fieldNumber: 4)
    }
    if !self.tumID.isEmpty {
      try visitor.visitSingularStringField(value: self.tumID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_ResponsiblePersonElement, rhs: Api_ResponsiblePersonElement) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.telephone != rhs.telephone {return false}
    if lhs.email != rhs.email {return false}
    if lhs.faculty != rhs.faculty {return false}
    if lhs.tumID != rhs.tumID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetBuilding2GpsReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetBuilding2GpsReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "building2Gps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.building2Gps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.building2Gps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.building2Gps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetBuilding2GpsReply, rhs: Api_GetBuilding2GpsReply) -> Bool {
    if lhs.building2Gps != rhs.building2Gps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_Building2GpsElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Building2GpsElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "latitude"),
    3: .same(proto: "longitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.latitude) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.longitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.latitude.isEmpty {
      try visitor.visitSingularStringField(value: self.latitude, fieldNumber: 2)
    }
    if !self.longitude.isEmpty {
      try visitor.visitSingularStringField(value: self.longitude, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_Building2GpsElement, rhs: Api_Building2GpsElement) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetAreaFacilitiesByBuildingNrReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAreaFacilitiesByBuildingNrReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "areaFacilitiesByBuildingNr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.areaFacilitiesByBuildingNr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.areaFacilitiesByBuildingNr.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.areaFacilitiesByBuildingNr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetAreaFacilitiesByBuildingNrReply, rhs: Api_GetAreaFacilitiesByBuildingNrReply) -> Bool {
    if lhs.areaFacilitiesByBuildingNr != rhs.areaFacilitiesByBuildingNr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetAreaFacilitiesByBuildingNrRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAreaFacilitiesByBuildingNrRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "building_nr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.buildingNr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buildingNr.isEmpty {
      try visitor.visitSingularStringField(value: self.buildingNr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetAreaFacilitiesByBuildingNrRequest, rhs: Api_GetAreaFacilitiesByBuildingNrRequest) -> Bool {
    if lhs.buildingNr != rhs.buildingNr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetListOfToiletsReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetListOfToiletsReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "listOfToilets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.listOfToilets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.listOfToilets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.listOfToilets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetListOfToiletsReply, rhs: Api_GetListOfToiletsReply) -> Bool {
    if lhs.listOfToilets != rhs.listOfToilets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_RoomInformationElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoomInformationElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roomId"),
    2: .standard(proto: "room_code"),
    3: .standard(proto: "building_nr"),
    4: .standard(proto: "arch_id"),
    5: .same(proto: "info"),
    6: .same(proto: "address"),
    7: .same(proto: "purpose"),
    8: .same(proto: "campus"),
    9: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.roomID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.roomCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.buildingNr) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.archID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.info) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.purpose) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.campus) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roomID != 0 {
      try visitor.visitSingularInt32Field(value: self.roomID, fieldNumber: 1)
    }
    if !self.roomCode.isEmpty {
      try visitor.visitSingularStringField(value: self.roomCode, fieldNumber: 2)
    }
    if !self.buildingNr.isEmpty {
      try visitor.visitSingularStringField(value: self.buildingNr, fieldNumber: 3)
    }
    if !self.archID.isEmpty {
      try visitor.visitSingularStringField(value: self.archID, fieldNumber: 4)
    }
    if !self.info.isEmpty {
      try visitor.visitSingularStringField(value: self.info, fieldNumber: 5)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 6)
    }
    if !self.purpose.isEmpty {
      try visitor.visitSingularStringField(value: self.purpose, fieldNumber: 7)
    }
    if !self.campus.isEmpty {
      try visitor.visitSingularStringField(value: self.campus, fieldNumber: 8)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_RoomInformationElement, rhs: Api_RoomInformationElement) -> Bool {
    if lhs.roomID != rhs.roomID {return false}
    if lhs.roomCode != rhs.roomCode {return false}
    if lhs.buildingNr != rhs.buildingNr {return false}
    if lhs.archID != rhs.archID {return false}
    if lhs.info != rhs.info {return false}
    if lhs.address != rhs.address {return false}
    if lhs.purpose != rhs.purpose {return false}
    if lhs.campus != rhs.campus {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetListOfElevatorsReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetListOfElevatorsReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "listOfElevators"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.listOfElevators) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.listOfElevators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.listOfElevators, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetListOfElevatorsReply, rhs: Api_GetListOfElevatorsReply) -> Bool {
    if lhs.listOfElevators != rhs.listOfElevators {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetMoreInformationReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMoreInformationReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "information"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.information) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.information.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.information, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetMoreInformationReply, rhs: Api_GetMoreInformationReply) -> Bool {
    if lhs.information != rhs.information {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_MoreInformationElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MoreInformationElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "category"),
    3: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.category) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 2)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_MoreInformationElement, rhs: Api_MoreInformationElement) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.category != rhs.category {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetOpeningTimesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetOpeningTimesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "language"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.language) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetOpeningTimesRequest, rhs: Api_GetOpeningTimesRequest) -> Bool {
    if lhs.language != rhs.language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetOpeningTimesReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetOpeningTimesReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "facilities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.facilities) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.facilities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.facilities, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetOpeningTimesReply, rhs: Api_GetOpeningTimesReply) -> Bool {
    if lhs.facilities != rhs.facilities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_OpeningTimesMsgElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpeningTimesMsgElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "category"),
    3: .same(proto: "name"),
    4: .same(proto: "address"),
    5: .same(proto: "room"),
    6: .standard(proto: "transport_station"),
    7: .standard(proto: "opening_hours"),
    8: .same(proto: "infos"),
    9: .same(proto: "url"),
    10: .same(proto: "language"),
    11: .standard(proto: "reference_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.category) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.room) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.transportStation) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.openingHours) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.infos) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.referenceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 4)
    }
    if !self.room.isEmpty {
      try visitor.visitSingularStringField(value: self.room, fieldNumber: 5)
    }
    if !self.transportStation.isEmpty {
      try visitor.visitSingularStringField(value: self.transportStation, fieldNumber: 6)
    }
    if !self.openingHours.isEmpty {
      try visitor.visitSingularStringField(value: self.openingHours, fieldNumber: 7)
    }
    if !self.infos.isEmpty {
      try visitor.visitSingularStringField(value: self.infos, fieldNumber: 8)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 9)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 10)
    }
    if self.referenceID != 0 {
      try visitor.visitSingularInt32Field(value: self.referenceID, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_OpeningTimesMsgElement, rhs: Api_OpeningTimesMsgElement) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.category != rhs.category {return false}
    if lhs.name != rhs.name {return false}
    if lhs.address != rhs.address {return false}
    if lhs.room != rhs.room {return false}
    if lhs.transportStation != rhs.transportStation {return false}
    if lhs.openingHours != rhs.openingHours {return false}
    if lhs.infos != rhs.infos {return false}
    if lhs.url != rhs.url {return false}
    if lhs.language != rhs.language {return false}
    if lhs.referenceID != rhs.referenceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetUpdateNoteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUpdateNoteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetUpdateNoteRequest, rhs: Api_GetUpdateNoteRequest) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetUpdateNoteReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUpdateNoteReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetUpdateNoteReply, rhs: Api_GetUpdateNoteReply) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetStudyRoomListReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetStudyRoomListReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rooms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rooms) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rooms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rooms, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetStudyRoomListReply, rhs: Api_GetStudyRoomListReply) -> Bool {
    if lhs.rooms != rhs.rooms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_StudyRoomMsgElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StudyRoomMsgElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "details"),
    4: .same(proto: "rooms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.details) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.rooms) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitSingularStringField(value: self.details, fieldNumber: 3)
    }
    if !self.rooms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rooms, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_StudyRoomMsgElement, rhs: Api_StudyRoomMsgElement) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.details != rhs.details {return false}
    if lhs.rooms != rhs.rooms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_StudyRoom: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StudyRoom"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .same(proto: "roomId"),
    3: .standard(proto: "room_code"),
    4: .standard(proto: "room_name"),
    5: .standard(proto: "building_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.roomID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.roomCode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.roomName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.buildingName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt32Field(value: self.groupID, fieldNumber: 1)
    }
    if self.roomID != 0 {
      try visitor.visitSingularInt32Field(value: self.roomID, fieldNumber: 2)
    }
    if !self.roomCode.isEmpty {
      try visitor.visitSingularStringField(value: self.roomCode, fieldNumber: 3)
    }
    if !self.roomName.isEmpty {
      try visitor.visitSingularStringField(value: self.roomName, fieldNumber: 4)
    }
    if !self.buildingName.isEmpty {
      try visitor.visitSingularStringField(value: self.buildingName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_StudyRoom, rhs: Api_StudyRoom) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.roomID != rhs.roomID {return false}
    if lhs.roomCode != rhs.roomCode {return false}
    if lhs.roomName != rhs.roomName {return false}
    if lhs.buildingName != rhs.buildingName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetEventListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetEventListRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eventId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.eventID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventID != 0 {
      try visitor.visitSingularInt32Field(value: self.eventID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetEventListRequest, rhs: Api_GetEventListRequest) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetEventListReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetEventListReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetEventListReply, rhs: Api_GetEventListReply) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_EventListMsgElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventListMsgElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "path"),
    3: .same(proto: "event"),
    4: .same(proto: "news"),
    5: .same(proto: "kino"),
    6: .same(proto: "file"),
    7: .same(proto: "title"),
    8: .same(proto: "description"),
    9: .same(proto: "locality"),
    10: .same(proto: "link"),
    11: .same(proto: "start"),
    12: .same(proto: "end"),
    13: .standard(proto: "ticket_group"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.event) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.news) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.kino) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.file) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.locality) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.link) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._start) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._end) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.ticketGroup) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    if self.event != 0 {
      try visitor.visitSingularInt32Field(value: self.event, fieldNumber: 3)
    }
    if self.news != 0 {
      try visitor.visitSingularInt32Field(value: self.news, fieldNumber: 4)
    }
    if self.kino != 0 {
      try visitor.visitSingularInt32Field(value: self.kino, fieldNumber: 5)
    }
    if self.file != 0 {
      try visitor.visitSingularInt32Field(value: self.file, fieldNumber: 6)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 7)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 8)
    }
    if !self.locality.isEmpty {
      try visitor.visitSingularStringField(value: self.locality, fieldNumber: 9)
    }
    if !self.link.isEmpty {
      try visitor.visitSingularStringField(value: self.link, fieldNumber: 10)
    }
    try { if let v = self._start {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    if self.ticketGroup != 0 {
      try visitor.visitSingularInt32Field(value: self.ticketGroup, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_EventListMsgElement, rhs: Api_EventListMsgElement) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.path != rhs.path {return false}
    if lhs.event != rhs.event {return false}
    if lhs.news != rhs.news {return false}
    if lhs.kino != rhs.kino {return false}
    if lhs.file != rhs.file {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.locality != rhs.locality {return false}
    if lhs.link != rhs.link {return false}
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs.ticketGroup != rhs.ticketGroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetKinoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetKinoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.lastID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lastID != 0 {
      try visitor.visitSingularInt32Field(value: self.lastID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetKinoRequest, rhs: Api_GetKinoRequest) -> Bool {
    if lhs.lastID != rhs.lastID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetKinoReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetKinoReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kinos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.kinos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.kinos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.kinos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetKinoReply, rhs: Api_GetKinoReply) -> Bool {
    if lhs.kinos != rhs.kinos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_KinoMsgElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KinoMsgElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "path"),
    3: .same(proto: "kino"),
    4: .same(proto: "date"),
    5: .same(proto: "created"),
    6: .same(proto: "title"),
    7: .same(proto: "year"),
    8: .same(proto: "runtime"),
    9: .same(proto: "genre"),
    10: .same(proto: "director"),
    11: .same(proto: "actors"),
    12: .same(proto: "rating"),
    13: .same(proto: "description"),
    14: .same(proto: "cover"),
    15: .same(proto: "trailer"),
    16: .same(proto: "link"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _path: String = String()
    var _kino: Int32 = 0
    var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _created: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _title: String = String()
    var _year: String = String()
    var _runtime: String = String()
    var _genre: String = String()
    var _director: String = String()
    var _actors: String = String()
    var _rating: String = String()
    var _description_p: String = String()
    var _cover: Int32 = 0
    var _trailer: String = String()
    var _link: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _path = source._path
      _kino = source._kino
      _date = source._date
      _created = source._created
      _title = source._title
      _year = source._year
      _runtime = source._runtime
      _genre = source._genre
      _director = source._director
      _actors = source._actors
      _rating = source._rating
      _description_p = source._description_p
      _cover = source._cover
      _trailer = source._trailer
      _link = source._link
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._path) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._kino) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._date) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._created) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._year) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._runtime) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._genre) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._director) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._actors) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._rating) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._cover) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._trailer) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._link) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 2)
      }
      if _storage._kino != 0 {
        try visitor.visitSingularInt32Field(value: _storage._kino, fieldNumber: 3)
      }
      try { if let v = _storage._date {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._created {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 6)
      }
      if !_storage._year.isEmpty {
        try visitor.visitSingularStringField(value: _storage._year, fieldNumber: 7)
      }
      if !_storage._runtime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._runtime, fieldNumber: 8)
      }
      if !_storage._genre.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genre, fieldNumber: 9)
      }
      if !_storage._director.isEmpty {
        try visitor.visitSingularStringField(value: _storage._director, fieldNumber: 10)
      }
      if !_storage._actors.isEmpty {
        try visitor.visitSingularStringField(value: _storage._actors, fieldNumber: 11)
      }
      if !_storage._rating.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rating, fieldNumber: 12)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 13)
      }
      if _storage._cover != 0 {
        try visitor.visitSingularInt32Field(value: _storage._cover, fieldNumber: 14)
      }
      if !_storage._trailer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._trailer, fieldNumber: 15)
      }
      if !_storage._link.isEmpty {
        try visitor.visitSingularStringField(value: _storage._link, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_KinoMsgElement, rhs: Api_KinoMsgElement) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._kino != rhs_storage._kino {return false}
        if _storage._date != rhs_storage._date {return false}
        if _storage._created != rhs_storage._created {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._year != rhs_storage._year {return false}
        if _storage._runtime != rhs_storage._runtime {return false}
        if _storage._genre != rhs_storage._genre {return false}
        if _storage._director != rhs_storage._director {return false}
        if _storage._actors != rhs_storage._actors {return false}
        if _storage._rating != rhs_storage._rating {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._cover != rhs_storage._cover {return false}
        if _storage._trailer != rhs_storage._trailer {return false}
        if _storage._link != rhs_storage._link {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SendFeedbackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendFeedbackRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "email"),
    3: .same(proto: "emailId"),
    4: .same(proto: "message"),
    5: .standard(proto: "image_count"),
    6: .same(proto: "latitude"),
    7: .same(proto: "longitude"),
    8: .same(proto: "osVersion"),
    9: .same(proto: "appVersion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.emailID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.imageCount) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.appVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    if !self.emailID.isEmpty {
      try visitor.visitSingularStringField(value: self.emailID, fieldNumber: 3)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 4)
    }
    if self.imageCount != 0 {
      try visitor.visitSingularInt32Field(value: self.imageCount, fieldNumber: 5)
    }
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 6)
    }
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 7)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 8)
    }
    if !self.appVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appVersion, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SendFeedbackRequest, rhs: Api_SendFeedbackRequest) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.email != rhs.email {return false}
    if lhs.emailID != rhs.emailID {return false}
    if lhs.message != rhs.message {return false}
    if lhs.imageCount != rhs.imageCount {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.appVersion != rhs.appVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SendFeedbackImageReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendFeedbackImageReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SendFeedbackImageReply, rhs: Api_SendFeedbackImageReply) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_SendFeedbackImageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendFeedbackImageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "imageNr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.imageNr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.imageNr != 0 {
      try visitor.visitSingularInt32Field(value: self.imageNr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_SendFeedbackImageRequest, rhs: Api_SendFeedbackImageRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.imageNr != rhs.imageNr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetMembersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMembersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lrzId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.lrzID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lrzID.isEmpty {
      try visitor.visitSingularStringField(value: self.lrzID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetMembersRequest, rhs: Api_GetMembersRequest) -> Bool {
    if lhs.lrzID != rhs.lrzID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetMembersReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMembersReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lrzId"),
    2: .same(proto: "name"),
    3: .same(proto: "memberId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.lrzID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.memberID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lrzID.isEmpty {
      try visitor.visitSingularStringField(value: self.lrzID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.memberID != 0 {
      try visitor.visitSingularInt32Field(value: self.memberID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetMembersReply, rhs: Api_GetMembersReply) -> Bool {
    if lhs.lrzID != rhs.lrzID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.memberID != rhs.memberID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetUploadStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUploadStatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lrzId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.lrzID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lrzID.isEmpty {
      try visitor.visitSingularStringField(value: self.lrzID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetUploadStatusRequest, rhs: Api_GetUploadStatusRequest) -> Bool {
    if lhs.lrzID != rhs.lrzID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetUploadStatusReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUploadStatusReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fcm_token"),
    2: .standard(proto: "public_key"),
    3: .standard(proto: "student_id"),
    4: .standard(proto: "employee_id"),
    5: .standard(proto: "external_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fcmToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.studentID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.employeeID) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.externalID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fcmToken.isEmpty {
      try visitor.visitSingularStringField(value: self.fcmToken, fieldNumber: 1)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 2)
    }
    if self.studentID != false {
      try visitor.visitSingularBoolField(value: self.studentID, fieldNumber: 3)
    }
    if self.employeeID != false {
      try visitor.visitSingularBoolField(value: self.employeeID, fieldNumber: 4)
    }
    if self.externalID != false {
      try visitor.visitSingularBoolField(value: self.externalID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetUploadStatusReply, rhs: Api_GetUploadStatusReply) -> Bool {
    if lhs.fcmToken != rhs.fcmToken {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.studentID != rhs.studentID {return false}
    if lhs.employeeID != rhs.employeeID {return false}
    if lhs.externalID != rhs.externalID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetNotificationsReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetNotificationsReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notificationId"),
    2: .same(proto: "type"),
    3: .same(proto: "title"),
    4: .same(proto: "description"),
    5: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.notificationID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.notificationID != 0 {
      try visitor.visitSingularInt32Field(value: self.notificationID, fieldNumber: 1)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetNotificationsReply, rhs: Api_GetNotificationsReply) -> Bool {
    if lhs.notificationID != rhs.notificationID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_NotificationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotificationsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notificationId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.notificationID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.notificationID != 0 {
      try visitor.visitSingularInt32Field(value: self.notificationID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_NotificationsRequest, rhs: Api_NotificationsRequest) -> Bool {
    if lhs.notificationID != rhs.notificationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetNotificationsConfirmReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetNotificationsConfirmReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetNotificationsConfirmReply, rhs: Api_GetNotificationsConfirmReply) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetCanteenHeadCountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetCanteenHeadCountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "canteenId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.canteenID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.canteenID.isEmpty {
      try visitor.visitSingularStringField(value: self.canteenID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetCanteenHeadCountRequest, rhs: Api_GetCanteenHeadCountRequest) -> Bool {
    if lhs.canteenID != rhs.canteenID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_GetCanteenHeadCountReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetCanteenHeadCountReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "maxCount"),
    3: .same(proto: "percent"),
    4: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.count) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.maxCount) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.percent) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.count != 0 {
      try visitor.visitSingularUInt32Field(value: self.count, fieldNumber: 1)
    }
    if self.maxCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxCount, fieldNumber: 2)
    }
    if self.percent != 0 {
      try visitor.visitSingularFloatField(value: self.percent, fieldNumber: 3)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Api_GetCanteenHeadCountReply, rhs: Api_GetCanteenHeadCountReply) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.maxCount != rhs.maxCount {return false}
    if lhs.percent != rhs.percent {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

